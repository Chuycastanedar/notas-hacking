
## Descripción

Why use p and q when I can use more? Connect with `nc jupiter.challenges.picoctf.org 3726`.

## Solución

Inicio conectándome al puerto, donde obtengo los datos de c, n y e.
```bash
┌──(kali㉿kali)-[~]
└─$ nc jupiter.challenges.picoctf.org 3726
c: 24491288261609181374741529336740392416023445696608841756291990558020028361616206438428289882582570849739273897777260551963306246577091201336960154421004395797939758606562662778369015787093869663603139819280865154079257677964574292514125044918517690623891667559987924922172629304557669456295621583180518503584240762029817420930320169640840934179
n: 49406628953087446896952417038401306257860359076615130062342955549939888454609639249215945223309452350891256841325294285822644378588048051820929370443127817890130087558094731187330378823084737768358393901152276108156308196788851229982698104898300794337193949206694025285532082527298613948321247851411004469549862390453386910824163920002828840151
e: 65537
```

De acuerdo a los datos que tengo y al documento RSA, calculo lo siguiente:
Declaro c, n y e:
```bash
┌──(kali㉿kali)-[~]
└─$ python3
Python 3.13.7 (main, Aug 20 2025, 22:17:40) [GCC 14.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> c = 244912882616091813747415293367403924160234456966088417562919905\
58020028361616206438428289882582570849739273897777260551963306246577091\
20133696015442100439579793975860656266277836901578709386966360313981928\
08651540792576779645742925141250449185176906238916675599879249221726293\
04557669456295621583180518503584240762029817420930320169640840934179
>>> 
>>> n = 494066289530874468969524170384013062578603590766151300623429555\
49939888454609639249215945223309452350891256841325294285822644378588048\
05182092937044312781789013008755809473118733037882308473776835839390115\
22761081563081967888512299826981048983007943371939492066940252855320825\
27298613948321247851411004469549862390453386910824163920002828840151
>>> 
>>> e = 65537
```

Como no me es posible factorizar y obtener solo 2 numeros tan facilmente, hago uso de la herramienta factorizar en la página alpertron.com pero para usar el Phi de Euler a partir de n.
Como me aparece con espacios le quito los espacios intermedios:
```bash
┌──(kali㉿kali)-[~]
└─$ echo "49 406628 819934 893030 135284 260361 255128 886641 929717 916955 681642 469517 920575 035966 088474 611322 107848 033854 683471 117402 529128 242328 940780 270495 410040 801925 742274 734431 302840 241566 293810 321755 597649 379410 497492 756355 482138 981092 579148 052630 140787 758230 683071 793521 866022 865806 183822 193230 483652 061091 056454 182778 420436 427341 824000 000000 000000 000000" | tr -d ' ' 
49406628819934893030135284260361255128886641929717916955681642469517920575035966088474611322107848033854683471117402529128242328940780270495410040801925742274734431302840241566293810321755597649379410497492756355482138981092579148052630140787758230683071793521866022865806183822193230483652061091056454182778420436427341824000000000000000000000
```

Ya con tn, calculo d, m y obtengo la bandera:
```bash
>>> tn = 49406628819934893030135284260361255128886641929717916955681642\
46951792057503596608847461132210784803385468347111740252912824232894078\
02704954100408019257422747344313028402415662938103217555976493794104974\
92756355482138981092579148052630140787758230683071793521866022865806183\
822193230483652061091056454182778420436427341824000000000000000000000
>>> 
>>> d = pow(e, -1, tn)
>>> 
>>> m = pow(c, d, n)
>>> 
>>> flag = bytes.fromhex( hex(m)[2:]).decode()
>>> 
>>> print(flag)
picoCTF{too_many_fact0rs_8606199}
```


## Notas adicionales


## Referencias

https://www.alpertron.com.ar/ECMC.HTM